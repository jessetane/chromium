# Copyright 2016 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This file contains rules that are shared between Mac and iOS.

import("//build/toolchain/toolchain.gni")
import("//build/config/mac/symbols.gni")

if (is_mac) {
  import("//build/config/mac/mac_sdk.gni")
} else if (is_ios) {
  import("//build/config/ios/ios_sdk.gni")
}

# Convert plist file to given format.
#
# Arguments
#
#   source:
#     string, path to the plist file to convert
#
#   output:
#     string, path to the converted plist, must be under $root_build_dir
#
#   format:
#     string, the format to `plutil -convert` the plist to.
template("convert_plist") {
  assert(defined(invoker.source), "source must be defined for $target_name")
  assert(defined(invoker.output), "output must be defined for $target_name")
  assert(defined(invoker.format), "format must be defined for $target_name")

  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "visibility",
                             "testonly",
                             "deps",
                           ])

    script = "//build/config/mac/xcrun.py"
    sources = [
      invoker.source,
    ]
    outputs = [
      invoker.output,
    ]
    args = [
      "plutil",
      "-convert",
      invoker.format,
      "-o",
      rebase_path(invoker.output, root_build_dir),
      rebase_path(invoker.source, root_build_dir),
    ]
  }
}

# The base template used to generate Info.plist files for iOS and Mac apps and
# frameworks.
#
# Arguments
#
#     plist_templates:
#         string array, paths to plist files which will be used for the bundle.
#
#     executable_name:
#         string, name of the generated target used for the product
#         and executable name as specified in the output Info.plist.
#
#     format:
#         string, the format to `plutil -convert` the plist to when
#         generating the output.
#
#     extra_substitutions:
#         (optional) string array, 'key=value' pairs for extra fields which are
#         specified in a source Info.plist template.
#
#     output_name:
#         (optional) string, name of the generated plist file, default to
#         "$target_gen_dir/$target_name.plist".
template("info_plist") {
  assert(defined(invoker.plist_templates),
         "A list of template plist files must be specified for $target_name")
  assert(defined(invoker.executable_name),
         "The executable_name must be specified for $target_name")
  assert(defined(invoker.format),
         "The plist format must be specified for $target_name")
  executable_name = invoker.executable_name

  _output_name = "$target_gen_dir/$target_name.plist"
  if (defined(invoker.output_name)) {
    _output_name = invoker.output_name
  }

  action(target_name) {
    script = "//build/config/mac/gen_plist.py"
    sources = invoker.plist_templates
    outputs = [
      _output_name,
    ]
    extra_args = []
    if (defined(invoker.extra_substitutions)) {
      foreach(substitution, invoker.extra_substitutions) {
        extra_args += [ "-s=$substitution" ]
      }
    }
    response_file_contents =
        extra_args + [
          "-s=BUILD_MACHINE_OS_BUILD=$machine_os_build",
          "-s=EXECUTABLE_NAME=$executable_name",
          "-s=GCC_VERSION=com.apple.compilers.llvm.clang.1_0",
          "-s=PRODUCT_NAME=$executable_name",
          "-s=XCODE_BUILD=$xcode_build",
          "-s=XCODE_VERSION=$xcode_version",
          "-o=" + rebase_path(_output_name, root_build_dir),
          "-f=" + invoker.format,
        ] + rebase_path(sources, root_build_dir)
    args = [ "@{{response_file_name}}" ]
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                             "visibility",
                           ])
  }
}

# This is used as the base template for both iOS and Mac frameworks.
#
# By default, the bundle target this template generates does not link the
# resulting framework into anything that depends on it. If a dependency wants
# a link-time (as well as build-time) dependency on the framework bundle,
# depend against "$target_name+link". If only the build-time dependency is
# required (e.g., for copying into another bundle), then use "$target_name".
#
# Arguments
#
#     output_name:
#         (optional) string, name of the generated framework without the
#         .framework suffix. If omitted, defaults to target_name.
#
#     framework_version:
#         (optional) string, version of the framework. Typically this is a
#         single letter, like "A". If omitted, the Versions/ subdirectory
#         structure will not be created, and build output will go directly
#         into the framework subdirectory.
#
# This template provides two targets for the resulting framework bundle. The
# link-time behavior varies depending on which of the two targets below is
# added as a dependency:
#   - $target_name only adds a build-time dependency. Targets that depend on
#     it will not link against the framework.
#   - $target_name+link adds a build-time and link-time dependency. Targets
#     that depend on it will link against the framework.
#
# The build-time-only dependency is used for when a target needs to use the
# framework either only for resources, or because the target loads it at run-
# time, via dlopen() or NSBundle. The link-time dependency will cause the
# dependee to have the framework loaded by dyld at launch.
#
# Example of build-time only dependency:
#
#     framework_bundle("CoreTeleportation") {
#       sources = [ ... ]
#     }
#
#     bundle_data("core_teleportation_bundle_data") {
#       deps = [ ":CoreTeleportation" ]
#       sources = [ "$root_out_dir/CoreTeleportation.framework" ]
#       outputs = [ "{{bundle_root_dir}}/Frameworks/{{source_file_part}}" ]
#     }
#
#     app_bundle("GoatTeleporter") {
#       sources = [ ... ]
#       deps = [
#         ":core_teleportation_bundle_data",
#       ]
#     }
#
# The GoatTeleporter.app will not directly link against
# CoreTeleportation.framework, but it will be included in the bundle's
# Frameworks directory.
#
# Example of link-time dependency:
#
#     framework_bundle("CoreTeleportation") {
#       sources = [ ... ]
#       ldflags = [
#         "-install_name",
#         "@executable_path/../Frameworks/$target_name.framework"
#       ]
#     }
#
#     bundle_data("core_teleportation_bundle_data") {
#       deps = [ ":CoreTeleportation+link" ]
#       sources = [ "$root_out_dir/CoreTeleportation.framework" ]
#       outputs = [ "{{bundle_root_dir}}/Frameworks/{{source_file_part}}" ]
#     }
#
#     app_bundle("GoatTeleporter") {
#       sources = [ ... ]
#       deps = [
#         ":core_teleportation_bundle_data",
#       ]
#     }
#
# Note that the framework is still copied to the app's bundle, but dyld will
# load this library when the app is launched because it uses the "+link"
# target as a dependency. This also requires that the framework set its
# install_name so that dyld can locate it.
#
# See "gn help shared_library" for more information on arguments supported
# by shared library target.
template("framework_bundle") {
  _target_name = target_name
  _output_name = target_name
  if (defined(invoker.output_name)) {
    _output_name = invoker.output_name
  }

  _is_fat_build = is_ios && additional_toolchains != []
  if (_is_fat_build) {
    _is_fat_build_main_target = current_toolchain == default_toolchain
  }

  # The expansion of the template is different for fat and thin builds. For
  # thin build (and default toolchain of a fat build), the template expands
  # to a "shared_library" target to create the bundle shared library and a
  # "create_bundle" target (the main target) to create the bundle structure.
  #
  # For a fat build, the template just expands to the "shared_library" target
  # for the non-default toolchain, while the final library is created using
  # "lipo" in the expansion of the template for the default toolchain.
  #
  # The "$target_name+link" group for the non-default toolchain depends on the
  # target of the same name from the default toolchain as this is the target
  # that defines the real framework bundle (it will support the current cpu
  # as it is a fat framework).

  if (_is_fat_build && !_is_fat_build_main_target) {
    shared_library(_target_name) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "assert_no_deps",
                               "bundle_deps",
                               "code_signing_enabled",
                               "data_deps",
                               "info_plist",
                               "info_plist_target",
                               "output_name",
                             ])
      if (defined(visibility)) {
        visibility += [ ":${_target_name}_shared_library($default_toolchain)" ]
      }
      output_name = _output_name
      output_prefix_override = true
      output_extension = ""
      output_dir = "$target_out_dir/$_target_name"
    }

    group(_target_name + "+link") {
      forward_variables_from(invoker,
                             [
                               "visibility",
                               "testonly",
                             ])
      public_deps = [
        ":$_target_name($default_toolchain)",
      ]
    }

    if (defined(invoker.bundle_deps)) {
      assert(invoker.bundle_deps != [], "mark bundle_deps as used")
    }
  } else {
    _code_signing_enabled = is_ios && ios_enable_code_signing
    if (defined(invoker.code_signing_enabled)) {
      _code_signing_enabled =
          invoker.code_signing_enabled && _code_signing_enabled
    }

    # If the framework is unversioned, the final _target_name will be the
    # create_bundle(_framework_target), otherwise an action with the name
    # _target_name will depends on the the create_bundle() in order to prepare
    # the versioned directory structure.
    _framework_target = _target_name
    _framework_name = _output_name + ".framework"
    _framework_root_dir = "$root_out_dir/$_framework_name"
    if (defined(invoker.framework_version) && invoker.framework_version != "") {
      _framework_version = invoker.framework_version
      _framework_root_dir += "/Versions/$_framework_version"
      _framework_target = _target_name + "_create_bundle"
    }

    _link_shared_library_target = target_name + "_shared_library"
    _shared_library_dir = "$target_out_dir/$_link_shared_library_target"

    if (_code_signing_enabled) {
      _link_shared_library_visibility = [ ":$_framework_target" ]
    } else {
      _shared_library_bundle_data = target_name + "_shared_library_bundle_data"
      _link_shared_library_visibility = [ ":$_shared_library_bundle_data" ]
    }

    if (_is_fat_build) {
      _lipo_shared_library_target = _link_shared_library_target
      _lipo_shared_library_visibility = _link_shared_library_visibility

      _link_shared_library_visibility = []
      _link_shared_library_visibility = [ ":$_lipo_shared_library_target" ]
      _link_shared_library_target = target_name + "_arch_shared_library"

      _arch_shared_library_dir = "$target_out_dir/$_link_shared_library_target"
      _shared_library_dir = "$target_out_dir/$_lipo_shared_library_target"
    }

    shared_library(_link_shared_library_target) {
      forward_variables_from(invoker,
                             "*",
                             [
                               "assert_no_deps",
                               "bundle_deps",
                               "code_signing_enabled",
                               "data_deps",
                               "info_plist",
                               "output_name",
                               "visibility",
                             ])
      visibility = _link_shared_library_visibility
      output_name = _output_name
      output_prefix_override = true
      output_extension = ""

      if (!_is_fat_build) {
        output_dir = _shared_library_dir
      } else {
        output_dir = _arch_shared_library_dir
      }
    }

    if (_is_fat_build) {
      action(_lipo_shared_library_target) {
        forward_variables_from(invoker, [ "testonly" ])
        visibility = _lipo_shared_library_visibility
        script = "//build/toolchain/mac/linker_driver.py"
        outputs = [
          "$_shared_library_dir/$_output_name",
        ]
        inputs = [
          "$_arch_shared_library_dir/$_output_name",
        ]
        deps = [
          ":$_link_shared_library_target",
        ]
        foreach(_additional_toolchain, additional_toolchains) {
          _additional_toolchain_target = "$_target_name($_additional_toolchain)"
          deps += [ ":$_additional_toolchain_target" ]
          inputs += [ get_label_info(_additional_toolchain_target,
                                     "target_out_dir") + "/$_output_name" ]
        }
        args = [
                 "xcrun",
                 "lipo",
                 "-create",
                 "-output",
                 rebase_path(outputs[0], root_build_dir),
               ] + rebase_path(inputs, root_build_dir)

        if (enable_dsyms) {
          outputs += [ "$root_out_dir/$_output_name.dSYM/" ]
          args +=
              [ "-Wcrl,dsym," + rebase_path("$root_out_dir/.", root_build_dir) ]
        }

        if (enable_stripping) {
          # Check whether //build/config/mac:strip_all has been removed from
          # the configs variable (as this is how stripping is disabled for a
          # single target).
          _strip_all_in_config = false
          if (defined(invoker.configs)) {
            foreach(_config, invoker.configs) {
              if (_config == "//build/config/mac:strip_all") {
                _strip_all_in_config = true
              }
            }
          }

          if (_strip_all_in_config) {
            args += [ "-Wcrl,strip,-x,-S" ]

            if (save_unstripped_output) {
              outputs += [ outputs[0] + ".unstripped" ]
              args += [ "-Wcrl,unstripped," +
                        rebase_path(get_path_info(outputs[0], "dir"),
                                    root_build_dir) ]
            }
          }
        }
      }
    }

    if (!_code_signing_enabled) {
      bundle_data(_shared_library_bundle_data) {
        visibility = [ ":$_framework_target" ]
        forward_variables_from(invoker, [ "testonly" ])
        sources = [
          "$_shared_library_dir/$_output_name",
        ]
        outputs = [
          "{{bundle_executable_dir}}/$_output_name",
        ]
        if (_is_fat_build) {
          public_deps = [
            ":$_lipo_shared_library_target",
          ]
        } else {
          public_deps = [
            ":$_link_shared_library_target",
          ]
        }
      }
    }

    _framework_public_config = _target_name + "_public_config"
    config(_framework_public_config) {
      # TODO(sdefresne): should we have a framework_dirs similar to lib_dirs
      # and include_dirs to avoid duplicate values on the command-line.
      visibility = [ ":$_framework_target" ]
      ldflags = [
        "-F",
        rebase_path("$root_out_dir/.", root_build_dir),
      ]
      lib_dirs = [ root_out_dir ]
      libs = [ _framework_name ]
    }

    create_bundle(_framework_target) {
      forward_variables_from(invoker,
                             [
                               "data_deps",
                               "deps",
                               "public_deps",
                               "testonly",
                             ])

      if (defined(_framework_version)) {
        visibility = [ ":$_target_name" ]
      } else {
        if (defined(invoker.visibility)) {
          visibility = invoker.visibility
          visibility += [ ":$_target_name+link" ]
        }
      }

      if (defined(invoker.bundle_deps)) {
        if (!defined(deps)) {
          deps = []
        }
        deps += invoker.bundle_deps
      }

      if (!_code_signing_enabled) {
        if (!defined(public_deps)) {
          public_deps = []
        }
        public_deps += [ ":$_shared_library_bundle_data" ]
      }

      bundle_root_dir = _framework_root_dir
      bundle_resources_dir = "$bundle_root_dir/Resources"
      bundle_executable_dir = "$bundle_root_dir"

      if (_code_signing_enabled) {
        if (!defined(deps)) {
          deps = []
        }

        if (_is_fat_build) {
          deps += [ ":$_lipo_shared_library_target" ]
        } else {
          deps += [ ":$_link_shared_library_target" ]
        }

        _entitlements_path = "$ios_sdk_path/Entitlements.plist"
        if (defined(invoker.entitlements_path)) {
          _entitlements_path = invoker.entitlements_path
        }

        code_signing_script = "//build/config/ios/codesign.py"
        code_signing_sources = [
          _entitlements_path,
          "$_shared_library_dir/$_output_name",
        ]
        code_signing_outputs = [
          "$bundle_root_dir/$_output_name",
          "$bundle_root_dir/_CodeSignature/CodeResources",
          "$bundle_root_dir/embedded.mobileprovision",
        ]
        code_signing_args = [
          "-i=" + ios_code_signing_identity,
          "-b=" +
              rebase_path("$_shared_library_dir/$_output_name", root_build_dir),
          "-e=" + rebase_path(_entitlements_path, root_build_dir),
          rebase_path(bundle_root_dir, root_build_dir),
        ]
      }
    }

    if (defined(_framework_version)) {
      action(_target_name) {
        forward_variables_from(invoker, [ "testonly" ])

        if (defined(invoker.visibility)) {
          visibility = invoker.visibility
          visibility += [ ":$_target_name+link" ]
        }

        script = "//build/config/mac/package_framework.py"
        outputs = [
          "$root_out_dir/$_framework_name/Versions/Current",
        ]
        args = [
          "$_framework_name",
          "$_framework_version",
        ]
        public_deps = [
          ":$_framework_target",
        ]
      }
    }

    group(_target_name + "+link") {
      forward_variables_from(invoker,
                             [
                               "public_configs",
                               "testonly",
                               "visibility",
                             ])
      public_deps = [
        ":$_target_name",
      ]
      if (!defined(public_configs)) {
        public_configs = []
      }
      public_configs += [ ":$_framework_public_config" ]
    }
  }
}

# Template to combile .xib or .storyboard files.
#
# Arguments
#
#     sources:
#         list of string, sources to compile
#
#     ibtool_flags:
#         (optional) list of string, additional flags to pass to the ibtool
template("compile_xibs") {
  action_foreach(target_name) {
    forward_variables_from(invoker,
                           [
                             "testonly",
                             "visibility",
                           ])
    assert(defined(invoker.sources),
           "Sources must be specified for $target_name")

    ibtool_flags = []
    if (defined(invoker.ibtool_flags)) {
      ibtool_flags = invoker.ibtool_flags
    }

    script = "//build/config/mac/compile_xib.py"
    sources = invoker.sources
    outputs = [
      "$target_gen_dir/$target_name/{{source_name_part}}.nib",
    ]
    args =
        [
          "--input",
          "{{source}}",
          "--output",
          rebase_path("$target_gen_dir/$target_name/{{source_name_part}}.nib"),
        ] + ibtool_flags
  }
}
